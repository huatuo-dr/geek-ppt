# 渲染插件开发指导

本文档说明如何为 Geek PPT 开发自定义渲染插件，将 Markdown 内容以你想要的视觉风格呈现在幻灯片中。

---

## 1. 架构概览

```
编辑器 Markdown
    ↓
unified/remark 解析为 AST
    ↓
Markdown 预处理 (可选，如 Torrent 的行合并)
    ↓
渲染插件提供 CSS 样式 & 容器结构
    ↓
Shadow DOM 隔离渲染到预览区
```

渲染插件的职责是 **提供 CSS 样式**，控制 Markdown 转换后的 HTML 在幻灯片中的视觉表现。HTML 结构由 unified/remark 管线统一生成，插件不需要操作 AST 或生成 HTML。

---

## 2. 插件接口

所有渲染插件必须实现 `RendererPlugin` 接口（定义在 `src/types/plugin.ts`）：

```typescript
interface RendererPlugin {
  /** 插件唯一标识，如 "my-renderer" */
  pluginId: string;
  /** 语义化版本号 */
  version: string;
  /** 在 UI 中显示的名称，如 "我的风格" */
  displayName: string;
  /** 声明支持的 Markdown 节点类型 */
  supportedNodeTypes: MarkdownNodeType[];
  /** 返回插件的完整 CSS 字符串 */
  getStyles(): string;
}
```

### 2.1 支持的节点类型

插件必须声明自己支持哪些 Markdown 语法节点。完整列表如下：

| 节点类型 | 对应 HTML 元素 | Markdown 语法 |
|----------|---------------|--------------|
| `heading` | `<h1>` ~ `<h6>` | `# 标题` |
| `paragraph` | `<p>` | 普通段落 |
| `strong` | `<strong>` | `**粗体**` |
| `emphasis` | `<em>` | `*斜体*` |
| `delete` | `<del>` | `~~删除线~~` |
| `link` | `<a>` | `[文本](url)` |
| `image` | `<img>` | `![alt](url)` |
| `inlineCode` | `<code>` | `` `代码` `` |
| `code` | `<pre><code>` | ` ```代码块``` ` |
| `blockquote` | `<blockquote>` | `> 引用` |
| `list` | `<ul>` / `<ol>` | `- 项目` / `1. 项目` |
| `listItem` | `<li>` | 列表项 |
| `table` | `<table>` | `\| 表头 \|` |
| `thematicBreak` | `<hr>` | `---` |
| `text` | 文本节点 | 普通文本 |
| `html` | 原始 HTML | HTML 标签 |

建议新插件声明支持全部节点类型，确保所有 Markdown 语法都有对应的渲染效果。

---

## 3. 开发步骤

### 3.1 创建插件目录

在 `src/plugins/` 下新建目录，例如 `src/plugins/neon/`：

```
src/plugins/neon/
├── index.ts          # 插件注册入口
└── neonStyles.ts     # CSS 样式
```

### 3.2 编写样式文件

`neonStyles.ts` 导出两个函数：

```typescript
/** 返回插件的完整 CSS */
export function getNeonStyles(): string {
  return `
.neon-slide {
  font-family: 'Inter', sans-serif;
  color: #ffffff;
  background: #0a0a0a;
  padding: 48px 64px;
  height: 100%;
  box-sizing: border-box;
  overflow-y: auto;
}
.neon-slide h1 {
  font-size: 3em;
  font-weight: 800;
  color: #00ff88;
  text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
}
.neon-slide p { margin: 0.6em 0; line-height: 1.8; }
.neon-slide strong { color: #ff6b6b; }
.neon-slide em { font-style: italic; color: #ffd93d; }
.neon-slide del { text-decoration: line-through; opacity: 0.5; }
.neon-slide a { color: #4ecdc4; text-decoration: underline; }
.neon-slide img { display: block; max-width: 80%; margin: 1em auto; border-radius: 8px; }
.neon-slide code { background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px; font-family: monospace; }
/* Shiki code block — choose light or dark theme */
.neon-slide pre.shiki span { color: var(--shiki-dark) !important; background-color: transparent !important; }
.neon-slide pre.shiki { background-color: var(--shiki-dark-bg, #1a1a2e) !important; border-radius: 8px; padding: 16px; overflow-x: auto; margin: 1em 0; }
.neon-slide pre:not(.shiki) { background: #1a1a2e; border-radius: 8px; padding: 16px; overflow-x: auto; margin: 1em 0; }
.neon-slide pre code { background: none; padding: 0; }
.neon-slide blockquote { border-left: 4px solid #00ff88; background: rgba(0,255,136,0.05); padding: 12px 20px; margin: 1em 0; }
.neon-slide ul { list-style: disc; padding-left: 1.5em; margin: 0.5em 0; }
.neon-slide ol { list-style: decimal; padding-left: 1.5em; margin: 0.5em 0; }
.neon-slide li { margin: 0.25em 0; }
.neon-slide table { width: 100%; border-collapse: collapse; margin: 1em 0; }
.neon-slide th { background: rgba(255,255,255,0.1); font-weight: 600; padding: 8px 12px; border: 1px solid rgba(255,255,255,0.15); }
.neon-slide td { padding: 8px 12px; border: 1px solid rgba(255,255,255,0.1); }
.neon-slide hr { border: none; height: 1px; background: linear-gradient(90deg, transparent, #00ff88, transparent); margin: 1.5em 0; width: 100%; }
`;
}

/** 返回外层包裹元素的 CSS class 名 */
export function getNeonWrapperClass(): string {
  return "neon-slide";
}
```

**关键要点**：

- 所有样式必须以 `.your-slide` 作为前缀，避免与其他插件或宿主冲突（渲染通过 Shadow DOM 隔离，但仍建议加前缀）
- `hr` 元素需要添加 `width: 100%`，否则在 flex 布局中会塌缩
- 代码块高亮由 Shiki 提供，使用 CSS 变量 `--shiki-light` / `--shiki-dark` 选择主题色
- 所有 HTML 元素都需要有对应样式，确保无遗漏

### 3.3 编写插件入口

`index.ts`：

```typescript
import type { RendererPlugin, MarkdownNodeType } from "@/types";
import { getNeonStyles } from "./neonStyles";

const ALL_NODE_TYPES: MarkdownNodeType[] = [
  "heading", "paragraph", "strong", "emphasis", "delete",
  "link", "image", "inlineCode", "code", "blockquote",
  "list", "listItem", "table", "thematicBreak", "text", "html",
];

export const neonRendererPlugin: RendererPlugin = {
  pluginId: "neon-renderer",
  version: "1.0.0",
  displayName: "霓虹",
  supportedNodeTypes: ALL_NODE_TYPES,
  getStyles: getNeonStyles,
};
```

### 3.4 注册插件

在 `src/plugins/index.ts` 中导入并注册：

```typescript
import { registerPlugin } from "@/services/pluginRegistry";
import { plainRendererPlugin } from "./plain";
import { coolRendererPlugin } from "./cool";
import { neonRendererPlugin } from "./neon";  // ← 新增

export function initPlugins(): void {
  registerPlugin(plainRendererPlugin);
  registerPlugin(coolRendererPlugin);
  registerPlugin(neonRendererPlugin);  // ← 新增
}
```

### 3.5 接入渲染服务

在 `src/services/renderService.ts` 中，通过以下步骤接入新插件：

1. **底座/渲染器识别**：
   在 `render()` 函数中识别目标渲染器（支持通过 `customCss` 中的魔法注释覆盖）：
   ```typescript
   let effectiveBase = req.pluginId;
   if (req.customCss) {
     const match = req.customCss.match(/\/\*\s*@theme-base:\s*(\w+)\s*\*\//);
     if (match?.[1]) {
       effectiveBase = `${match[1]}-renderer`;
     }
   }
   ```

2. **预处理逻辑**：
   如果需要对 Markdown 文本进行特殊处理（如 Torrent 的行合并）：
   ```typescript
   const preprocessed = effectiveBase === "torrent-renderer" 
     ? torrentPreprocess(req.markdown) 
     : req.markdown;
   ```

3. **骨架与样式组装**：
   根据识别出的渲染器 ID，合并样式并生成 HTML 骨架：
   ```typescript
   if (effectiveBase === "torrent-renderer") {
     // 优先使用自定义样式覆盖底座样式
     css = req.customCss ? getTorrentStyles() + "\n" + css : getTorrentStyles();
     wrapperClass = getTorrentWrapperClass();
     inner = getTorrentInnerHtml(rawHtml);
   }
   ```

完成后，在工具栏的"渲染"下拉列表中就能看到新插件了。

---

## 4. 代码高亮集成

Geek PPT 使用 [Shiki](https://shiki.style/) 进行代码块语法高亮，已集成在 unified 渲染管线中。Shiki 生成的 `<pre class="shiki">` 元素包含 CSS 变量：

- `--shiki-light` / `--shiki-light-bg` — 亮色主题（github-light）
- `--shiki-dark` / `--shiki-dark-bg` — 暗色主题（tokyo-night）

在插件 CSS 中选择使用哪套：

```css
/* 使用亮色主题 */
.my-slide pre.shiki span { color: var(--shiki-light) !important; }
.my-slide pre.shiki { background-color: var(--shiki-light-bg) !important; }

/* 使用暗色主题 */
.my-slide pre.shiki span { color: var(--shiki-dark) !important; }
.my-slide pre.shiki { background-color: var(--shiki-dark-bg) !important; }
```

---

## 5. 样式隔离说明

预览区使用 **Shadow DOM** 隔离渲染输出。插件的 CSS 通过 `<style>` 标签注入到 Shadow Root 中，与宿主应用的 Tailwind CSS 完全隔离，互不影响。

这意味着：
- 插件可以自由使用任何 CSS，不必担心污染主界面
- 插件无法访问宿主的 Tailwind 工具类
- 每个插件的样式仅在激活时生效

---

## 6. 测试你的插件

### 6.1 视觉测试

在编辑器中输入覆盖所有语法的 Markdown，切换到你的插件查看渲染效果：

```markdown
# 一级标题
## 二级标题

普通段落，包含 **粗体**、*斜体*、~~删除线~~、`行内代码`。

[链接](https://example.com) 和 ![图片](https://via.placeholder.com/200)

> 这是一段引用

- 无序列表项 1
- 无序列表项 2

1. 有序列表项 1
2. 有序列表项 2

---

| 表头A | 表头B |
|-------|-------|
| 单元格 | 单元格 |

```javascript
console.log("代码高亮测试");
```
```

### 6.2 单元测试

在 `src/__tests__/` 中添加测试，验证插件注册和 CSS 输出：

```typescript
import { describe, it, expect } from "vitest";
import { neonRendererPlugin } from "@/plugins/neon";

describe("neonRendererPlugin", () => {
  it("should have correct pluginId", () => {
    expect(neonRendererPlugin.pluginId).toBe("neon-renderer");
  });

  it("should support all required node types", () => {
    const required = ["heading", "paragraph", "strong", "emphasis",
      "code", "blockquote", "list", "table", "thematicBreak"];
    for (const type of required) {
      expect(neonRendererPlugin.supportedNodeTypes).toContain(type);
    }
  });

  it("should return non-empty CSS", () => {
    expect(neonRendererPlugin.getStyles().length).toBeGreaterThan(100);
  });
});
```

运行测试：

```bash
npm test
```

---

## 7. 注意事项

1. **`pluginId` 必须唯一**，建议使用 `{name}-renderer` 格式
2. **`displayName`** 会直接显示在工具栏下拉列表中，保持简短（2-4 个字）
3. **所有 16 种节点类型都应有对应样式**，避免出现无样式的裸 HTML
4. **性能考虑**：避免在 CSS 中使用过多 `blur()`、`box-shadow` 等高开销属性，低端设备可能会卡顿（参考 `src/services/performanceDetector.ts` 的降级策略）
5. **`hr` 元素务必设置 `width: 100%`**，否则在 flex 容器中不可见
